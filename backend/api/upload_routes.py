from flask import Blueprint, jsonify, request, current_app
from backend.database_models import Track, Playlist, db
from backend.services.save_uploaded_files import save_uploaded_files
upload_bp = Blueprint('upload_bp', __name__)

@upload_bp.route('/upload-song', methods=['POST'])
def upload_song():
    try:
        # Convert string boolean values to Python booleans
        tiktok = request.form.get('tiktok', 'false').lower() == 'true'
        youtube = request.form.get('youtube', 'false').lower() == 'true'
        spotify = request.form.get('spotify', 'false').lower() == 'true'
        instagram = request.form.get('instagram', 'false').lower() == 'true'
        soundcloud = request.form.get('soundcloud', 'false').lower() == 'true'

        # Extract form data and files
        title       = request.form.get('title')
        description = request.form.get('description')
        producer    = request.form.get('producer')
        writer      = request.form.get('writer')
        genre       = request.form.get('genre')
        playlist_name = request.form.get('playlist_name')
        tiktok=tiktok
        youtube=youtube
        spotify=spotify
        instagram=instagram
        soundcloud=soundcloud

        song_file = request.files.get('song_file')
        img_file  = request.files.get('img_file')

        # xd
        if not title or not description or not producer or not writer or not genre or not song_file or not img_file:
            return jsonify({'error': 'one or more required fields are empty'}), 400

        # Create the new track object.
        # Temporarily set file path fields as empty strings until they are generated by save_uploaded_files.
        new_track = Track(
            title=title,
            description=description,
            producer=producer,
            writer=writer,
            song_path='',   
            img_path='',    
            genre=genre,
            tiktok=tiktok,
            youtube=youtube,
            spotify=spotify,
            instagram=instagram
        )

        # Add the track to the session and flush so we get an ID for file saving.
        db.session.add(new_track)
        db.session.flush()  # new_track.id is now available

        # Save uploaded files using the new track's id and update the track's file fields.
        file_paths = save_uploaded_files(song_file, img_file, new_track.id)
        current_app.logger.info(f"File paths: {file_paths}")  
        new_track.song_path = file_paths['song_path']
        new_track.img_path  = file_paths['img_path']

        # Associate the track with a playlist if a playlist name was provided.
        # If the playlist does not exist yet, create it.
        if playlist_name:
            playlist = Playlist.query.filter_by(name=playlist_name).first()
            if not playlist:
                playlist = Playlist(name=playlist_name)
                db.session.add(playlist)
            playlist.tracks.append(new_track)

        # Commit all changes (track creation, file path update, and playlist association)
        db.session.commit()

        return jsonify({
            'message': 'Song uploaded successfully'       
        }), 201

    except Exception as e:
        db.session.rollback() 
        current_app.logger.error(f"Error uploading song: {e}")
        return jsonify({'error': 'An error occurred while uploading the song'}), 500
